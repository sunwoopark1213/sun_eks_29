# ####################################################################################################
# V. GitHb Action 워크플로우 구성( CI )
# ====================================================================================================
 
# 1. GhiHub Repository 생성: https://github.com/csjin21c/ArgoCD.git
# 2. GitHub Secrets 설정
#    - AWS_ACCESS_KEY_ID: <액세스 키 ID>
#    - AWS_SECRET_ACCESS_KEY: <비밀 액세스 키>
# 3. 프로젝트 디렉토리 구조
.
├── .DS_Store
├── .git
├── .github
│   └── workflows
│       └── argocd-ci.yaml
├── .gitignore
├── k8s
│   └── web-deployment-nodeport.yaml
├── nginx
│   ├── default.conf
│   ├── Dockerfile
│   └── html
│       ├── images
│       │   └── nginx.png
│       └── index.html
└── README.md
# ====================================================================================================
# 4. .github/workflows/argocd-ci.yaml
# ----------------------------------------------------------------------------------------------------
name: Build and Push to ECR

on:
  push:
    branches: ["main"]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ap-northeast-1

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build & Push FastAPI
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker build -t $ECR_REGISTRY/sun/fastapi:$IMAGE_TAG ./fastapi
          docker push $ECR_REGISTRY/sun/fastapi:$IMAGE_TAG

      - name: Build & Push Nginx
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker build -t $ECR_REGISTRY/sun/nginx:$IMAGE_TAG ./nginx
          docker push $ECR_REGISTRY/sun/nginx:$IMAGE_TAG


# ####################################################################################################
# VI. ArgoCD 설치
# ====================================================================================================

# 1. ArgoCD를 위한 별도의 방(Namespace) 만들기
kubectl create namespace argocd

# 2. 공식 설치 스크립트 실행
kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml

# 3. ArgoCD 서버 외부 노출 (접속하기)
# 설치 직후에는 ArgoCD 대시보드가 클러스터 내부에 숨어있습니다. 관리자가 웹 브라우저로 접속할 수 있도록 서비스를 로드밸런서 타입으로 변경해줍니다.
kubectl patch svc argocd-server -n argocd -p '{"spec": {"type": "LoadBalancer"}}'

# 4. 서비스 타입을 LoadBalancer로 변경
kubectl patch svc argocd-server -n argocd -p '{"spec": {"type": "LoadBalancer"}}'

# 5. 서버를 --insecure 모드로 변경: 기본적으로 HTTPS로 구동되게 되어있으나 아직 인증서가 없는 관계로 HTTP 프로토콜로 구동 될 수 있도록 수정
kubectl patch deployment argocd-server -n argocd --type='json' \
    -p='[{"op": "add", "path": "/spec/template/spec/containers/0/command", "value": ["argocd-server", "--insecure"]}]'

# 6. 아래 명령어로 접속 주소(External IP)가 생성될 때까지 기다렸다가 확인합니다.
kubectl get svc argocd-server -n argocd

# 7. ArgoCD 로그인 아이디는 admin입니다. 비밀번호는 아래 명령어로 추출할 수 있는 초기 생성값이니 메모해 두세요.
kubectl -n argocd get secret argocd-initial-admin-secret \
    -o jsonpath="{.data.password}" | base64 -d # admin / jRcwhtfKDEqTz713 ==> 맥의 경우 뒤에 %는 삭제

# 8. ArgoCD UI에서 비밀번호 수정: User Info > Update Password

# 참고 ----------
# ArgoCD 삭제: 문제가 발생할 경우 아르고씨디를 삭제후 재시도
# 설치할 때 썼던 매니페스트를 이용해 역으로 삭제
kubectl delete -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml

# 네임스페이스까지 완전히 삭제 (시간이 좀 걸릴 수 있습니다)
kubectl delete namespace argocd

# 비밀번호를 'admin123'으로 변경하는 명령어
kubectl -n argocd patch secret argocd-initial-admin-secret -p "{\"data\": {\"password\": \"$(echo -n 'admin1234!' | base64)\"}}"

# ArgoCD 재식작
kubectl rollout restart deployment argocd-server -n argocd
# ----------




# ####################################################################################################
# VII. ArgoCD 배포 설정
# ====================================================================================================

# 1. GitHub Repository 정보 등록
# ArgoCD Setting > Repositories > CONNECT REPO 
# 주요 입력 사항
# ----------------------------------------------------------------------------------------------------
# 항목                          내용
# ----------------------------------------------------------------------------------------------------
# Type	                        git (기본값)
# Name	                        ArgoCD 내부에서 리포지토리를 식별하는 별명입니다.(예. csjin-eks-repo)
# Project	                      default (드롭다운에서 선택하거나 직접 입력)
# Repository URL	              준비하신 GitHub 주소 (예: https://github.com/csjin21c/ArgoCD.git)
# Username	                    csjin21c (GitHub 계정명)
# Password	                    [중요] GitHub  **Personal Access Token(PAT)**
# Bearer token	                비트버킷(Bitbucket) 등 특정 서비스에서만 쓰는 방식입니다.
# TLS client certificate	      자체 서명된 인증서를 쓰는 기업 내부망 환경이 아니면 필요 없습니다.
# TLS client certificate key	  위 항목과 세트이며, 일반적인 GitHub 연동에는 쓰지 않습니다.
# ----------------------------------------------------------------------------------------------------
# 1-1. GitHub Personal Access Token(PAT) 발급
# 발급순서: 
#   GitHub > GitHub 사용자 Icon > Setting > (사이드 메뉴 최 하단)Developer settings > Personal access tokens
#   > Tokens (classic) > Generate new token > Generate new tonen (classic) > Verify via email 
#   > 메일에서 인증번호 확인 > 입력 및 Verify
#   New personal access token (classic)
#    - Note: ArgoCD-Token (나중에 알아보기 쉽게 작성)
#    - Expiration(만료일): No expiration (학습용으로 사용을 위해 만료 기한 없음을 선택)
#    - Select scopes: repo 체크, ArgoCD가 GitHub에 있는 소스 코드를 읽어오려면 이 권한이 반드시 필요합니다.
#   화면 하단 "Generate token" 버튼 클릭 => token 복사

# 1-2. GitHub Actions에게 Repository로 Push할 수 있는 권한 부여
# GitHub Repository > Setting > (Side menu)Actions > General
# - 페이지 하단 Workflow permissions를 "Read and write permissions"로 수정
# - Allow GitHub Actions to create and approve pull requests에 체크
#    --> 이체크를 통해 단순히 파일 수정을 넘어 "Pull Request(PR)"를 직접 생성하거나 승인할 수 있는 권한까지 부여하는 것입니다.


# 2. Application 만들기
# 생성 순서:
#   (Side Menu)Applications > "NEW APP" > 아래 내용 입력 > "CREATE"
# 1) GENERAL (일반 설정)
# - Application Name: 애플리케이션 이름(예. csjin-eks-app)
# - Project: `default`
# - Sync Policy: `Automatic`을 선택하면 Git에 push만 해도 자동으로 배포가 됩니다.
# 2) SOURCE (소스 설정)
# - Repository URL: 등록한 GitHub Repository를 선택합니다.
# - Revision: `HEAD` (기본값)
# - Path: [중요] 생성할 Application(POD)관련 메니페스트(YAML) 파일이 있는 위치를 지정합니다.(예. k8s)
# 3) DESTINATION (목적지 설정)
# - Cluster URL: https://kubernetes.default.svc 선택
# - Namespace: default 선택 (혹은, 배포를 원하는 특정 네임스페이스)
#     - 여기서는 default로 놓는 것이 좋습니다.
#     - 메니페스트 파일에 네임스페이스를 정의 했을 경우 우선하게 됩니다.
#     - 메니페스트 파일의 네임스페이스와 ArgoCD의 이곳 네임스페이스가 다를 경우 메니페이스를 우선하게 됩니다. 다만, 이때 `OutOfSync(비동기)`경고를 띄울 수 있습니다.
# 4) Directory (생략) : Directory 섹션은 일반적으로 정의하지 않습니다. Path 항목에서 정의된 내용으로 대체 됩니다.
#   [ Directory 역할 ]
#   - Recures (재귀적 탐색): 만약 k8s 폴더 안에 또 다른 하위 폴더들이 있다면, 이 옵션을 체크해야 하위 폴더의 YAML까지 모두 배포하게 됩니다. 다만, Path에서 지정한 폴더 바로 아래 파일만 대상이 됩니다.
#   - 특정 파일 제외 (Exclude): 폴더 안에 배포하고 싶지 않은 설정 파일(예: `README.md`나 임시 파일)이 섞여 있을 때, 특정 패턴을 가진 파일을 배포에서 제외할 수 있습니다.
#   - JSON/YAML 외 포맷 지원: 기본적으로 `.yaml`, `.yml`, `.json` 파일만 읽지만, 설정에 따라 다른 형식의 매니페스트를 처리하도록 커스텀할 때 사용합니다.






# 깃 명령
# 1. 머지(Merge) 방식을 기본으로 사용하도록 설정(처음에만)
git config pull.rebase false

# 3. 내 변경 사항(Nginx 설정) 스테이징 및 커밋
git pull origin main --no-rebase
git add .
git commit -m "Fix: Pull & Push"

# 4. 최종 Pull & Push
git push origin main